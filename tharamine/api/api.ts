/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.1
 * source: api/api.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../google/api/annotations";
import * as dependency_2 from "./../protoc-gen-openapiv2/options/annotations";
import * as dependency_3 from "./../trade_aggregation";
import * as dependency_4 from "./../trade";
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace api {
    export enum PointType {
        UNKNOWN_TYPE = 0,
        TRADE = 1,
        TRADE_AGG = 9
    }
    export enum PointSide {
        UNKNOWN_SIDE = 0,
        SELL = 1,
        BUY = 2
    }
    export enum PointExchange {
        UNKNOWN_EXCHANGE = 0,
        BITMEX = 1,
        DERIBIT = 2,
        BINANCE_FUTURES = 3,
        BINANCE_DELIVERY = 4,
        BINANCE = 6,
        FTX = 7,
        OKEX_FUTURES = 8,
        OKEX_OPTIONS = 9,
        OKEX_SWAP = 10,
        OKEX = 11,
        BITFINEX_DERIVATIVES = 16,
        BITFINEX = 17,
        COINBASE = 18,
        CRYPTOFACILITIES = 19,
        KRAKEN = 20,
        BITSTAMP = 21,
        GEMINI = 22,
        BYBIT = 24,
        BYBIT_SPOT = 60,
        NYSE_AMERICAN = 61,
        NASDAQ_BX = 62,
        NYSE_NATIONAL = 63,
        FINRA = 64,
        CBOE_EDGA = 67,
        CBOE_EDGX = 68,
        NYSE_CHICAGO = 69,
        NYSE = 70,
        NYSE_ARCA = 71,
        NASDAQ = 72,
        LTSE = 74,
        IEX = 75,
        NASDAQ_PHILADELPHIA = 77,
        CBOE_BYX = 78,
        CBOE_BZX = 79,
        MIAX_PEARL = 80,
        MEMBERS_EXCHANGE = 81,
        OTC_EQUITY_SECURITY = 82
    }
    export enum PointCategory {
        UNKNOWN_CATEGORY = 0,
        SPOT = 1,
        PERPETUAL = 2,
        FUTURE = 3,
        OPTION = 4,
        COMBO = 5
    }
    export enum PointAggregationInterval {
        UNKNOWN_AGGREGATION_INTERVAL = 0,
        MINUTE = 2,
        FIVE_MINUTES = 3,
        FIFTEEN_MINUTES = 4,
        HOUR = 5,
        FOUR_HOURS = 6,
        DAY = 7,
        WEEK = 8
    }
    export class PointMetaRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: PointType[];
            exchange?: PointExchange[];
            category?: PointCategory[];
            coin?: string[];
            rawSymbol?: string[];
            from?: number;
            to?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2, 3, 4, 5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("exchange" in data && data.exchange != undefined) {
                    this.exchange = data.exchange;
                }
                if ("category" in data && data.category != undefined) {
                    this.category = data.category;
                }
                if ("coin" in data && data.coin != undefined) {
                    this.coin = data.coin;
                }
                if ("rawSymbol" in data && data.rawSymbol != undefined) {
                    this.rawSymbol = data.rawSymbol;
                }
                if ("from" in data && data.from != undefined) {
                    this.from = data.from;
                }
                if ("to" in data && data.to != undefined) {
                    this.to = data.to;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as PointType[];
        }
        set type(value: PointType[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get exchange() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as PointExchange[];
        }
        set exchange(value: PointExchange[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get category() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as PointCategory[];
        }
        set category(value: PointCategory[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get coin() {
            return pb_1.Message.getFieldWithDefault(this, 4, []) as string[];
        }
        set coin(value: string[]) {
            pb_1.Message.setField(this, 4, value);
        }
        get rawSymbol() {
            return pb_1.Message.getFieldWithDefault(this, 5, []) as string[];
        }
        set rawSymbol(value: string[]) {
            pb_1.Message.setField(this, 5, value);
        }
        get from() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set from(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get to() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set to(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            type?: PointType[];
            exchange?: PointExchange[];
            category?: PointCategory[];
            coin?: string[];
            rawSymbol?: string[];
            from?: number;
            to?: number;
        }): PointMetaRequest {
            const message = new PointMetaRequest({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.exchange != null) {
                message.exchange = data.exchange;
            }
            if (data.category != null) {
                message.category = data.category;
            }
            if (data.coin != null) {
                message.coin = data.coin;
            }
            if (data.rawSymbol != null) {
                message.rawSymbol = data.rawSymbol;
            }
            if (data.from != null) {
                message.from = data.from;
            }
            if (data.to != null) {
                message.to = data.to;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: PointType[];
                exchange?: PointExchange[];
                category?: PointCategory[];
                coin?: string[];
                rawSymbol?: string[];
                from?: number;
                to?: number;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.exchange != null) {
                data.exchange = this.exchange;
            }
            if (this.category != null) {
                data.category = this.category;
            }
            if (this.coin != null) {
                data.coin = this.coin;
            }
            if (this.rawSymbol != null) {
                data.rawSymbol = this.rawSymbol;
            }
            if (this.from != null) {
                data.from = this.from;
            }
            if (this.to != null) {
                data.to = this.to;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type.length)
                writer.writePackedEnum(1, this.type);
            if (this.exchange.length)
                writer.writePackedEnum(2, this.exchange);
            if (this.category.length)
                writer.writePackedEnum(3, this.category);
            if (this.coin.length)
                writer.writeRepeatedString(4, this.coin);
            if (this.rawSymbol.length)
                writer.writeRepeatedString(5, this.rawSymbol);
            if (this.from != 0)
                writer.writeInt64(6, this.from);
            if (this.to != 0)
                writer.writeInt64(7, this.to);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PointMetaRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PointMetaRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readPackedEnum();
                        break;
                    case 2:
                        message.exchange = reader.readPackedEnum();
                        break;
                    case 3:
                        message.category = reader.readPackedEnum();
                        break;
                    case 4:
                        pb_1.Message.addToRepeatedField(message, 4, reader.readString());
                        break;
                    case 5:
                        pb_1.Message.addToRepeatedField(message, 5, reader.readString());
                        break;
                    case 6:
                        message.from = reader.readInt64();
                        break;
                    case 7:
                        message.to = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PointMetaRequest {
            return PointMetaRequest.deserialize(bytes);
        }
    }
    export class PointResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            series?: PointSeries[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("series" in data && data.series != undefined) {
                    this.series = data.series;
                }
            }
        }
        get series() {
            return pb_1.Message.getRepeatedWrapperField(this, PointSeries, 1) as PointSeries[];
        }
        set series(value: PointSeries[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            series?: ReturnType<typeof PointSeries.prototype.toObject>[];
        }): PointResponse {
            const message = new PointResponse({});
            if (data.series != null) {
                message.series = data.series.map(item => PointSeries.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                series?: ReturnType<typeof PointSeries.prototype.toObject>[];
            } = {};
            if (this.series != null) {
                data.series = this.series.map((item: PointSeries) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.series.length)
                writer.writeRepeatedMessage(1, this.series, (item: PointSeries) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PointResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PointResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.series, () => pb_1.Message.addToRepeatedWrapperField(message, 1, PointSeries.deserialize(reader), PointSeries));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PointResponse {
            return PointResponse.deserialize(bytes);
        }
    }
    export class PointMetaResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            types?: PointType[];
            exchanges?: PointExchange[];
            categories?: PointCategory[];
            coins?: string[];
            rawSymbols?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2, 3, 4, 6], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("types" in data && data.types != undefined) {
                    this.types = data.types;
                }
                if ("exchanges" in data && data.exchanges != undefined) {
                    this.exchanges = data.exchanges;
                }
                if ("categories" in data && data.categories != undefined) {
                    this.categories = data.categories;
                }
                if ("coins" in data && data.coins != undefined) {
                    this.coins = data.coins;
                }
                if ("rawSymbols" in data && data.rawSymbols != undefined) {
                    this.rawSymbols = data.rawSymbols;
                }
            }
        }
        get types() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as PointType[];
        }
        set types(value: PointType[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get exchanges() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as PointExchange[];
        }
        set exchanges(value: PointExchange[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get categories() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as PointCategory[];
        }
        set categories(value: PointCategory[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get coins() {
            return pb_1.Message.getFieldWithDefault(this, 4, []) as string[];
        }
        set coins(value: string[]) {
            pb_1.Message.setField(this, 4, value);
        }
        get rawSymbols() {
            return pb_1.Message.getFieldWithDefault(this, 6, []) as string[];
        }
        set rawSymbols(value: string[]) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            types?: PointType[];
            exchanges?: PointExchange[];
            categories?: PointCategory[];
            coins?: string[];
            rawSymbols?: string[];
        }): PointMetaResponse {
            const message = new PointMetaResponse({});
            if (data.types != null) {
                message.types = data.types;
            }
            if (data.exchanges != null) {
                message.exchanges = data.exchanges;
            }
            if (data.categories != null) {
                message.categories = data.categories;
            }
            if (data.coins != null) {
                message.coins = data.coins;
            }
            if (data.rawSymbols != null) {
                message.rawSymbols = data.rawSymbols;
            }
            return message;
        }
        toObject() {
            const data: {
                types?: PointType[];
                exchanges?: PointExchange[];
                categories?: PointCategory[];
                coins?: string[];
                rawSymbols?: string[];
            } = {};
            if (this.types != null) {
                data.types = this.types;
            }
            if (this.exchanges != null) {
                data.exchanges = this.exchanges;
            }
            if (this.categories != null) {
                data.categories = this.categories;
            }
            if (this.coins != null) {
                data.coins = this.coins;
            }
            if (this.rawSymbols != null) {
                data.rawSymbols = this.rawSymbols;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.types.length)
                writer.writePackedEnum(1, this.types);
            if (this.exchanges.length)
                writer.writePackedEnum(2, this.exchanges);
            if (this.categories.length)
                writer.writePackedEnum(3, this.categories);
            if (this.coins.length)
                writer.writeRepeatedString(4, this.coins);
            if (this.rawSymbols.length)
                writer.writeRepeatedString(6, this.rawSymbols);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PointMetaResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PointMetaResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.types = reader.readPackedEnum();
                        break;
                    case 2:
                        message.exchanges = reader.readPackedEnum();
                        break;
                    case 3:
                        message.categories = reader.readPackedEnum();
                        break;
                    case 4:
                        pb_1.Message.addToRepeatedField(message, 4, reader.readString());
                        break;
                    case 6:
                        pb_1.Message.addToRepeatedField(message, 6, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PointMetaResponse {
            return PointMetaResponse.deserialize(bytes);
        }
    }
    export class PointRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: PointType[];
            exchange?: PointExchange[];
            normalizedSymbol?: string[];
            coin?: string[];
            category?: PointCategory[];
            rawSymbol?: string[];
            side?: PointSide;
            interval?: PointAggregationInterval;
            from?: number;
            period?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2, 3, 4, 5, 6], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("exchange" in data && data.exchange != undefined) {
                    this.exchange = data.exchange;
                }
                if ("normalizedSymbol" in data && data.normalizedSymbol != undefined) {
                    this.normalizedSymbol = data.normalizedSymbol;
                }
                if ("coin" in data && data.coin != undefined) {
                    this.coin = data.coin;
                }
                if ("category" in data && data.category != undefined) {
                    this.category = data.category;
                }
                if ("rawSymbol" in data && data.rawSymbol != undefined) {
                    this.rawSymbol = data.rawSymbol;
                }
                if ("side" in data && data.side != undefined) {
                    this.side = data.side;
                }
                if ("interval" in data && data.interval != undefined) {
                    this.interval = data.interval;
                }
                if ("from" in data && data.from != undefined) {
                    this.from = data.from;
                }
                if ("period" in data && data.period != undefined) {
                    this.period = data.period;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as PointType[];
        }
        set type(value: PointType[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get exchange() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as PointExchange[];
        }
        set exchange(value: PointExchange[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get normalizedSymbol() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
        }
        set normalizedSymbol(value: string[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get coin() {
            return pb_1.Message.getFieldWithDefault(this, 4, []) as string[];
        }
        set coin(value: string[]) {
            pb_1.Message.setField(this, 4, value);
        }
        get category() {
            return pb_1.Message.getFieldWithDefault(this, 5, []) as PointCategory[];
        }
        set category(value: PointCategory[]) {
            pb_1.Message.setField(this, 5, value);
        }
        get rawSymbol() {
            return pb_1.Message.getFieldWithDefault(this, 6, []) as string[];
        }
        set rawSymbol(value: string[]) {
            pb_1.Message.setField(this, 6, value);
        }
        get side() {
            return pb_1.Message.getFieldWithDefault(this, 8, PointSide.UNKNOWN_SIDE) as PointSide;
        }
        set side(value: PointSide) {
            pb_1.Message.setField(this, 8, value);
        }
        get interval() {
            return pb_1.Message.getFieldWithDefault(this, 12, PointAggregationInterval.UNKNOWN_AGGREGATION_INTERVAL) as PointAggregationInterval;
        }
        set interval(value: PointAggregationInterval) {
            pb_1.Message.setField(this, 12, value);
        }
        get from() {
            return pb_1.Message.getFieldWithDefault(this, 14, 0) as number;
        }
        set from(value: number) {
            pb_1.Message.setField(this, 14, value);
        }
        get period() {
            return pb_1.Message.getFieldWithDefault(this, 15, 0) as number;
        }
        set period(value: number) {
            pb_1.Message.setField(this, 15, value);
        }
        static fromObject(data: {
            type?: PointType[];
            exchange?: PointExchange[];
            normalizedSymbol?: string[];
            coin?: string[];
            category?: PointCategory[];
            rawSymbol?: string[];
            side?: PointSide;
            interval?: PointAggregationInterval;
            from?: number;
            period?: number;
        }): PointRequest {
            const message = new PointRequest({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.exchange != null) {
                message.exchange = data.exchange;
            }
            if (data.normalizedSymbol != null) {
                message.normalizedSymbol = data.normalizedSymbol;
            }
            if (data.coin != null) {
                message.coin = data.coin;
            }
            if (data.category != null) {
                message.category = data.category;
            }
            if (data.rawSymbol != null) {
                message.rawSymbol = data.rawSymbol;
            }
            if (data.side != null) {
                message.side = data.side;
            }
            if (data.interval != null) {
                message.interval = data.interval;
            }
            if (data.from != null) {
                message.from = data.from;
            }
            if (data.period != null) {
                message.period = data.period;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: PointType[];
                exchange?: PointExchange[];
                normalizedSymbol?: string[];
                coin?: string[];
                category?: PointCategory[];
                rawSymbol?: string[];
                side?: PointSide;
                interval?: PointAggregationInterval;
                from?: number;
                period?: number;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.exchange != null) {
                data.exchange = this.exchange;
            }
            if (this.normalizedSymbol != null) {
                data.normalizedSymbol = this.normalizedSymbol;
            }
            if (this.coin != null) {
                data.coin = this.coin;
            }
            if (this.category != null) {
                data.category = this.category;
            }
            if (this.rawSymbol != null) {
                data.rawSymbol = this.rawSymbol;
            }
            if (this.side != null) {
                data.side = this.side;
            }
            if (this.interval != null) {
                data.interval = this.interval;
            }
            if (this.from != null) {
                data.from = this.from;
            }
            if (this.period != null) {
                data.period = this.period;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type.length)
                writer.writePackedEnum(1, this.type);
            if (this.exchange.length)
                writer.writePackedEnum(2, this.exchange);
            if (this.normalizedSymbol.length)
                writer.writeRepeatedString(3, this.normalizedSymbol);
            if (this.coin.length)
                writer.writeRepeatedString(4, this.coin);
            if (this.category.length)
                writer.writePackedEnum(5, this.category);
            if (this.rawSymbol.length)
                writer.writeRepeatedString(6, this.rawSymbol);
            if (this.side != PointSide.UNKNOWN_SIDE)
                writer.writeEnum(8, this.side);
            if (this.interval != PointAggregationInterval.UNKNOWN_AGGREGATION_INTERVAL)
                writer.writeEnum(12, this.interval);
            if (this.from != 0)
                writer.writeInt64(14, this.from);
            if (this.period != 0)
                writer.writeInt64(15, this.period);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PointRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PointRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readPackedEnum();
                        break;
                    case 2:
                        message.exchange = reader.readPackedEnum();
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                        break;
                    case 4:
                        pb_1.Message.addToRepeatedField(message, 4, reader.readString());
                        break;
                    case 5:
                        message.category = reader.readPackedEnum();
                        break;
                    case 6:
                        pb_1.Message.addToRepeatedField(message, 6, reader.readString());
                        break;
                    case 8:
                        message.side = reader.readEnum();
                        break;
                    case 12:
                        message.interval = reader.readEnum();
                        break;
                    case 14:
                        message.from = reader.readInt64();
                        break;
                    case 15:
                        message.period = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PointRequest {
            return PointRequest.deserialize(bytes);
        }
    }
    export class PointSeriesIdentifier extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: PointType;
            rawSymbol?: string;
            exchange?: PointExchange;
            normalizedSymbol?: string;
            category?: PointCategory;
            interval?: PointAggregationInterval;
            side?: PointSide;
            coin?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("rawSymbol" in data && data.rawSymbol != undefined) {
                    this.rawSymbol = data.rawSymbol;
                }
                if ("exchange" in data && data.exchange != undefined) {
                    this.exchange = data.exchange;
                }
                if ("normalizedSymbol" in data && data.normalizedSymbol != undefined) {
                    this.normalizedSymbol = data.normalizedSymbol;
                }
                if ("category" in data && data.category != undefined) {
                    this.category = data.category;
                }
                if ("interval" in data && data.interval != undefined) {
                    this.interval = data.interval;
                }
                if ("side" in data && data.side != undefined) {
                    this.side = data.side;
                }
                if ("coin" in data && data.coin != undefined) {
                    this.coin = data.coin;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 2, PointType.UNKNOWN_TYPE) as PointType;
        }
        set type(value: PointType) {
            pb_1.Message.setField(this, 2, value);
        }
        get rawSymbol() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set rawSymbol(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get exchange() {
            return pb_1.Message.getFieldWithDefault(this, 4, PointExchange.UNKNOWN_EXCHANGE) as PointExchange;
        }
        set exchange(value: PointExchange) {
            pb_1.Message.setField(this, 4, value);
        }
        get normalizedSymbol() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set normalizedSymbol(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get category() {
            return pb_1.Message.getFieldWithDefault(this, 7, PointCategory.UNKNOWN_CATEGORY) as PointCategory;
        }
        set category(value: PointCategory) {
            pb_1.Message.setField(this, 7, value);
        }
        get interval() {
            return pb_1.Message.getFieldWithDefault(this, 8, PointAggregationInterval.UNKNOWN_AGGREGATION_INTERVAL) as PointAggregationInterval;
        }
        set interval(value: PointAggregationInterval) {
            pb_1.Message.setField(this, 8, value);
        }
        get side() {
            return pb_1.Message.getFieldWithDefault(this, 11, PointSide.UNKNOWN_SIDE) as PointSide;
        }
        set side(value: PointSide) {
            pb_1.Message.setField(this, 11, value);
        }
        get coin() {
            return pb_1.Message.getFieldWithDefault(this, 20, "") as string;
        }
        set coin(value: string) {
            pb_1.Message.setField(this, 20, value);
        }
        static fromObject(data: {
            type?: PointType;
            rawSymbol?: string;
            exchange?: PointExchange;
            normalizedSymbol?: string;
            category?: PointCategory;
            interval?: PointAggregationInterval;
            side?: PointSide;
            coin?: string;
        }): PointSeriesIdentifier {
            const message = new PointSeriesIdentifier({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.rawSymbol != null) {
                message.rawSymbol = data.rawSymbol;
            }
            if (data.exchange != null) {
                message.exchange = data.exchange;
            }
            if (data.normalizedSymbol != null) {
                message.normalizedSymbol = data.normalizedSymbol;
            }
            if (data.category != null) {
                message.category = data.category;
            }
            if (data.interval != null) {
                message.interval = data.interval;
            }
            if (data.side != null) {
                message.side = data.side;
            }
            if (data.coin != null) {
                message.coin = data.coin;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: PointType;
                rawSymbol?: string;
                exchange?: PointExchange;
                normalizedSymbol?: string;
                category?: PointCategory;
                interval?: PointAggregationInterval;
                side?: PointSide;
                coin?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.rawSymbol != null) {
                data.rawSymbol = this.rawSymbol;
            }
            if (this.exchange != null) {
                data.exchange = this.exchange;
            }
            if (this.normalizedSymbol != null) {
                data.normalizedSymbol = this.normalizedSymbol;
            }
            if (this.category != null) {
                data.category = this.category;
            }
            if (this.interval != null) {
                data.interval = this.interval;
            }
            if (this.side != null) {
                data.side = this.side;
            }
            if (this.coin != null) {
                data.coin = this.coin;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type != PointType.UNKNOWN_TYPE)
                writer.writeEnum(2, this.type);
            if (this.rawSymbol.length)
                writer.writeString(3, this.rawSymbol);
            if (this.exchange != PointExchange.UNKNOWN_EXCHANGE)
                writer.writeEnum(4, this.exchange);
            if (this.normalizedSymbol.length)
                writer.writeString(6, this.normalizedSymbol);
            if (this.category != PointCategory.UNKNOWN_CATEGORY)
                writer.writeEnum(7, this.category);
            if (this.interval != PointAggregationInterval.UNKNOWN_AGGREGATION_INTERVAL)
                writer.writeEnum(8, this.interval);
            if (this.side != PointSide.UNKNOWN_SIDE)
                writer.writeEnum(11, this.side);
            if (this.coin.length)
                writer.writeString(20, this.coin);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PointSeriesIdentifier {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PointSeriesIdentifier();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        message.type = reader.readEnum();
                        break;
                    case 3:
                        message.rawSymbol = reader.readString();
                        break;
                    case 4:
                        message.exchange = reader.readEnum();
                        break;
                    case 6:
                        message.normalizedSymbol = reader.readString();
                        break;
                    case 7:
                        message.category = reader.readEnum();
                        break;
                    case 8:
                        message.interval = reader.readEnum();
                        break;
                    case 11:
                        message.side = reader.readEnum();
                        break;
                    case 20:
                        message.coin = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PointSeriesIdentifier {
            return PointSeriesIdentifier.deserialize(bytes);
        }
    }
    export class Point extends pb_1.Message {
        #one_of_decls: number[][] = [[7, 15], [1]];
        constructor(data?: any[] | ({} & (({
            trade?: dependency_4.Trade;
            tradeAggregation?: never;
        } | {
            trade?: never;
            tradeAggregation?: dependency_3.TradeAggregation;
        }) | ({
            id?: PointSeriesIdentifier;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("trade" in data && data.trade != undefined) {
                    this.trade = data.trade;
                }
                if ("tradeAggregation" in data && data.tradeAggregation != undefined) {
                    this.tradeAggregation = data.tradeAggregation;
                }
            }
        }
        get id() {
            return pb_1.Message.getWrapperField(this, PointSeriesIdentifier, 1) as PointSeriesIdentifier;
        }
        set id(value: PointSeriesIdentifier) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[1], value);
        }
        get has_id() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get trade() {
            return pb_1.Message.getWrapperField(this, dependency_4.Trade, 7) as dependency_4.Trade;
        }
        set trade(value: dependency_4.Trade) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_trade() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get tradeAggregation() {
            return pb_1.Message.getWrapperField(this, dependency_3.TradeAggregation, 15) as dependency_3.TradeAggregation;
        }
        set tradeAggregation(value: dependency_3.TradeAggregation) {
            pb_1.Message.setOneofWrapperField(this, 15, this.#one_of_decls[0], value);
        }
        get has_tradeAggregation() {
            return pb_1.Message.getField(this, 15) != null;
        }
        get point() {
            const cases: {
                [index: number]: "none" | "trade" | "tradeAggregation";
            } = {
                0: "none",
                7: "trade",
                15: "tradeAggregation"
            };
            return cases[pb_1.Message.computeOneofCase(this, [7, 15])];
        }
        get _id() {
            const cases: {
                [index: number]: "none" | "id";
            } = {
                0: "none",
                1: "id"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        static fromObject(data: {
            id?: ReturnType<typeof PointSeriesIdentifier.prototype.toObject>;
            trade?: ReturnType<typeof dependency_4.Trade.prototype.toObject>;
            tradeAggregation?: ReturnType<typeof dependency_3.TradeAggregation.prototype.toObject>;
        }): Point {
            const message = new Point({});
            if (data.id != null) {
                message.id = PointSeriesIdentifier.fromObject(data.id);
            }
            if (data.trade != null) {
                message.trade = dependency_4.Trade.fromObject(data.trade);
            }
            if (data.tradeAggregation != null) {
                message.tradeAggregation = dependency_3.TradeAggregation.fromObject(data.tradeAggregation);
            }
            return message;
        }
        toObject() {
            const data: {
                id?: ReturnType<typeof PointSeriesIdentifier.prototype.toObject>;
                trade?: ReturnType<typeof dependency_4.Trade.prototype.toObject>;
                tradeAggregation?: ReturnType<typeof dependency_3.TradeAggregation.prototype.toObject>;
            } = {};
            if (this.id != null) {
                data.id = this.id.toObject();
            }
            if (this.trade != null) {
                data.trade = this.trade.toObject();
            }
            if (this.tradeAggregation != null) {
                data.tradeAggregation = this.tradeAggregation.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_id)
                writer.writeMessage(1, this.id, () => this.id.serialize(writer));
            if (this.has_trade)
                writer.writeMessage(7, this.trade, () => this.trade.serialize(writer));
            if (this.has_tradeAggregation)
                writer.writeMessage(15, this.tradeAggregation, () => this.tradeAggregation.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Point {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Point();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.id, () => message.id = PointSeriesIdentifier.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.trade, () => message.trade = dependency_4.Trade.deserialize(reader));
                        break;
                    case 15:
                        reader.readMessage(message.tradeAggregation, () => message.tradeAggregation = dependency_3.TradeAggregation.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Point {
            return Point.deserialize(bytes);
        }
    }
    export class PointSeries extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: PointSeriesIdentifier;
            points?: Point[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("points" in data && data.points != undefined) {
                    this.points = data.points;
                }
            }
        }
        get id() {
            return pb_1.Message.getWrapperField(this, PointSeriesIdentifier, 2) as PointSeriesIdentifier;
        }
        set id(value: PointSeriesIdentifier) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_id() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get points() {
            return pb_1.Message.getRepeatedWrapperField(this, Point, 3) as Point[];
        }
        set points(value: Point[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            id?: ReturnType<typeof PointSeriesIdentifier.prototype.toObject>;
            points?: ReturnType<typeof Point.prototype.toObject>[];
        }): PointSeries {
            const message = new PointSeries({});
            if (data.id != null) {
                message.id = PointSeriesIdentifier.fromObject(data.id);
            }
            if (data.points != null) {
                message.points = data.points.map(item => Point.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                id?: ReturnType<typeof PointSeriesIdentifier.prototype.toObject>;
                points?: ReturnType<typeof Point.prototype.toObject>[];
            } = {};
            if (this.id != null) {
                data.id = this.id.toObject();
            }
            if (this.points != null) {
                data.points = this.points.map((item: Point) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_id)
                writer.writeMessage(2, this.id, () => this.id.serialize(writer));
            if (this.points.length)
                writer.writeRepeatedMessage(3, this.points, (item: Point) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PointSeries {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PointSeries();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        reader.readMessage(message.id, () => message.id = PointSeriesIdentifier.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.points, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Point.deserialize(reader), Point));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PointSeries {
            return PointSeries.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedAPIService {
        static definition = {
            GetPoints: {
                path: "/api.API/GetPoints",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: PointRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => PointRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: PointResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => PointResponse.deserialize(new Uint8Array(bytes))
            },
            StreamPoints: {
                path: "/api.API/StreamPoints",
                requestStream: false,
                responseStream: true,
                requestSerialize: (message: PointRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => PointRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: PointSeries) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => PointSeries.deserialize(new Uint8Array(bytes))
            },
            GetTypes: {
                path: "/api.API/GetTypes",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: PointMetaRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => PointMetaRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: PointMetaResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => PointMetaResponse.deserialize(new Uint8Array(bytes))
            },
            GetExchanges: {
                path: "/api.API/GetExchanges",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: PointMetaRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => PointMetaRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: PointMetaResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => PointMetaResponse.deserialize(new Uint8Array(bytes))
            },
            GetCategories: {
                path: "/api.API/GetCategories",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: PointMetaRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => PointMetaRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: PointMetaResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => PointMetaResponse.deserialize(new Uint8Array(bytes))
            },
            GetCoins: {
                path: "/api.API/GetCoins",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: PointMetaRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => PointMetaRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: PointMetaResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => PointMetaResponse.deserialize(new Uint8Array(bytes))
            },
            GetRawSymbols: {
                path: "/api.API/GetRawSymbols",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: PointMetaRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => PointMetaRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: PointMetaResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => PointMetaResponse.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract GetPoints(call: grpc_1.ServerUnaryCall<PointRequest, PointResponse>, callback: grpc_1.sendUnaryData<PointResponse>): void;
        abstract StreamPoints(call: grpc_1.ServerWritableStream<PointRequest, PointSeries>): void;
        abstract GetTypes(call: grpc_1.ServerUnaryCall<PointMetaRequest, PointMetaResponse>, callback: grpc_1.sendUnaryData<PointMetaResponse>): void;
        abstract GetExchanges(call: grpc_1.ServerUnaryCall<PointMetaRequest, PointMetaResponse>, callback: grpc_1.sendUnaryData<PointMetaResponse>): void;
        abstract GetCategories(call: grpc_1.ServerUnaryCall<PointMetaRequest, PointMetaResponse>, callback: grpc_1.sendUnaryData<PointMetaResponse>): void;
        abstract GetCoins(call: grpc_1.ServerUnaryCall<PointMetaRequest, PointMetaResponse>, callback: grpc_1.sendUnaryData<PointMetaResponse>): void;
        abstract GetRawSymbols(call: grpc_1.ServerUnaryCall<PointMetaRequest, PointMetaResponse>, callback: grpc_1.sendUnaryData<PointMetaResponse>): void;
    }
    export class APIClient extends grpc_1.makeGenericClientConstructor(UnimplementedAPIService.definition, "API", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        GetPoints: GrpcUnaryServiceInterface<PointRequest, PointResponse> = (message: PointRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<PointResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<PointResponse>, callback?: grpc_1.requestCallback<PointResponse>): grpc_1.ClientUnaryCall => {
            return super.GetPoints(message, metadata, options, callback);
        };
        StreamPoints: GrpcStreamServiceInterface<PointRequest, PointSeries> = (message: PointRequest, metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<PointSeries> => {
            return super.StreamPoints(message, metadata, options);
        };
        GetTypes: GrpcUnaryServiceInterface<PointMetaRequest, PointMetaResponse> = (message: PointMetaRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<PointMetaResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<PointMetaResponse>, callback?: grpc_1.requestCallback<PointMetaResponse>): grpc_1.ClientUnaryCall => {
            return super.GetTypes(message, metadata, options, callback);
        };
        GetExchanges: GrpcUnaryServiceInterface<PointMetaRequest, PointMetaResponse> = (message: PointMetaRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<PointMetaResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<PointMetaResponse>, callback?: grpc_1.requestCallback<PointMetaResponse>): grpc_1.ClientUnaryCall => {
            return super.GetExchanges(message, metadata, options, callback);
        };
        GetCategories: GrpcUnaryServiceInterface<PointMetaRequest, PointMetaResponse> = (message: PointMetaRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<PointMetaResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<PointMetaResponse>, callback?: grpc_1.requestCallback<PointMetaResponse>): grpc_1.ClientUnaryCall => {
            return super.GetCategories(message, metadata, options, callback);
        };
        GetCoins: GrpcUnaryServiceInterface<PointMetaRequest, PointMetaResponse> = (message: PointMetaRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<PointMetaResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<PointMetaResponse>, callback?: grpc_1.requestCallback<PointMetaResponse>): grpc_1.ClientUnaryCall => {
            return super.GetCoins(message, metadata, options, callback);
        };
        GetRawSymbols: GrpcUnaryServiceInterface<PointMetaRequest, PointMetaResponse> = (message: PointMetaRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<PointMetaResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<PointMetaResponse>, callback?: grpc_1.requestCallback<PointMetaResponse>): grpc_1.ClientUnaryCall => {
            return super.GetRawSymbols(message, metadata, options, callback);
        };
    }
}
